# Copyright 2017 syzkaller project authors. All rights reserved.
# Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.

include <sys/types.h>
include <sys/mman.h>
include <sys/stat.h>
include <fcntl.h>
include <unistd.h>
include <poll.h>
include <sys/file.h>
include <sys/socket.h>
include <sys/uio.h>
include <sys/param.h>
include <sys/resource.h>
include <time.h>
include <signal.h>
include <sys/wait.h>
include <sys/time.h>
include <limits.h>

type signo int32[0:_POSIX_RTSIG_MAX]

syz_execute_func(text ptr[in, text[target]])

fcntl$getflags(fd fd, cmd flags[fcntl_getflags])
fcntl$setflags(fd fd, cmd const[F_SETFD], flags flags[fcntl_flags])
fcntl$lock(fd fd, cmd flags[fcntl_lock], lock ptr[in, flock])

mknod(file ptr[in, filename], mode flags[mknod_mode], dev int32)
chmod(file ptr[in, filename], mode flags[open_mode])
fchmod(fd fd, mode flags[open_mode])
fchmodat(dirfd fd_dir, file ptr[in, filename], mode flags[open_mode], flags flags[at_flags])
chown(file ptr[in, filename], uid uid, gid gid)
lchown(file ptr[in, filename], uid uid, gid gid)
fchown(fd fd, uid uid, gid gid)
fchownat(dirfd fd_dir, file ptr[in, filename], uid uid, gid gid, flags flags[at_flags])
access(pathname ptr[in, filename], mode flags[access_mode])

execve(file ptr[in, filename], argv ptr[in, array[ptr[in, string]]], envp ptr[in, array[ptr[in, string]]])

getgid() gid
getegid() gid
setuid(uid uid)
setgid(gid gid)
getuid() uid
geteuid() uid
setegid(egid gid)
seteuid(euid uid)
getsid(pid pid) pid
setsid() pid
setpgid(pid pid, pgid pid)
getpgid(pid pid) pid
getpgrp(pid pid) pid
getpid() pid
getppid() pid
setreuid(ruid uid, euid uid)
setresuid(ruid uid, euid uid, suid uid)
setresgid(rgid gid, egid gid, sgid gid)
getresuid(ruid ptr[out, uid], euid ptr[out, uid], suid ptr[out, uid])
getresgid(rgid ptr[out, gid], egid ptr[out, gid], sgid ptr[out, gid])
getgroups(size len[list], list ptr[inout, array[gid]])
setgroups(size len[list], list ptr[in, array[gid]])
getlogin(buf buffer[out], size len[buf])

link(old ptr[in, filename], new ptr[in, filename])
symlink(old ptr[in, filename], new ptr[in, filename])
unlink(path ptr[in, filename])
readlink(path ptr[in, filename], buf buffer[out], siz len[buf])
rename(old ptr[in, filename], new ptr[in, filename])
mkdir(path ptr[in, filename], mode flags[open_mode])
rmdir(path ptr[in, filename])
truncate(file ptr[in, filename], len intptr)
ftruncate(fd fd, len intptr)
fsync(fd fd)
sync()
chroot(dir ptr[in, filename])
chdir(dir ptr[in, filename])
fchdir(fd fd)

clock_gettime(id flags[clock_id], tp ptr[out, timespec])
clock_settime(id flags[clock_id], tp ptr[in, timespec])
clock_getres(id flags[clock_id], tp ptr[out, timespec])
clock_nanosleep(id flags[clock_id], flags flags[timer_flags], rqtp ptr[in, timespec], rmtp ptr[out, timespec, opt])
sigaction(signo signo, act ptr[in, sigaction], oact ptr[out, sigaction, opt])
sigprocmask(how flags[sigprocmask_how], set ptr[in, sigset, opt], oset ptr[out, sigset, opt])
sigsuspend(sigmask ptr[in, sigset])
sigpending(set ptr[out, sigset])
sigtimedwait(set ptr[in, sigset], info ptr[out, siginfo, opt], timeout ptr[in, timespec])
sigwaitinfo(set ptr[in, sigset], info ptr[out, siginfo, opt])
sigwait(set ptr[in, sigset], sig intptr)
sigaltstack(ss vma, oss ptr[out, intptr, opt])
nanosleep(req ptr[in, timespec], rem ptr[out, timespec, opt])
exit(code intptr)
fork() pid
vfork() pid
umask(mode flags[open_mode])

sigaction {
	sigaction_u	ptr[in, text[target]]
	sa_flags	flags[sigaction_flags, int32]
	sa_mask		sigset
}

sigset {
	mask	int32
}

siginfo {
	si_signo	int32
	si_errno	int32
	si_code		int32
	si_pid		pid
	si_uid		uid
	si_status	int32
	si_addr		intptr
	si_value	sigval
	reason		reason
}

sigval [
	sival_int	int32
	sival_ptr	intptr
	sigval_int	int32
	sigval_ptr	intptr
]

reason [
	fault	fault_r
	timer	timer_r
	mesgq	mesgq_r
	poll	poll_r
	spare	spare_r
]

fault_r {
	trapno	int32
}

timer_r {
	timerid	int32
	overrun	int32
}

mesgq_r {
	mqd	int32
}

poll_r {
	band	intptr
}

spare_r {
	spare1	intptr
	spare2	array[int32, 7]
}

timespec {
	sec	intptr
	nsec	intptr
}

flock {
	type	flags[flock_type, int16]
	whence	flags[seek_whence, int16]
	start	intptr
	len	intptr
	pid	pid
}

mknod_mode = S_IFREG, S_IFCHR, S_IFBLK, S_IFIFO, S_IFSOCK, S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH
at_flags = 0, AT_SYMLINK_NOFOLLOW
access_mode = R_OK, W_OK, X_OK, F_OK

clock_id = CLOCK_REALTIME, CLOCK_MONOTONIC, CLOCK_MONOTONIC_RAW, CLOCK_REALTIME_COARSE, CLOCK_MONOTONIC_COARSE
timer_flags = 0
fcntl_getflags = F_GETFD, F_GETFL
fcntl_lock = F_SETLK, F_SETLKW, F_GETLK
fcntl_flags = FD_CLOEXEC
flock_type = F_RDLCK, F_WRLCK, F_UNLCK

sigprocmask_how = SIG_BLOCK, SIG_UNBLOCK, SIG_SETMASK
sigaction_flags = SA_NOCLDSTOP, SA_NOCLDWAIT, SA_ONSTACK, SA_NODEFER, SA_RESETHAND, SA_RESTART, SA_SIGINFO
